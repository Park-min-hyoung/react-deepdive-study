---
title: 01장 정리
date: '2024/04/03'
description: 리액트 개발을 위해 꼭 알아야 할 자바스크립트
---

# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

- null 과 undefined

  - null : 의도적으로 값이 없음을 나타내는 값 : typeof : null -> object
  - undefined : 값이 할당되지 않은 상태 typeof : undefined -> undefined

- Boolean

  - falsy : false, 0, -0, 0n, "", null, undefined, NaN
  - truthy : falsy를 제외한 모든 값
    - 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다

- Number

  - BigInt : 큰 정수를 표현하기 위한 자바스크립트의 새로운 원시 타입
    - 숫자 뒤에 n을 붙여서 생성한다
    - typeof : bigint
      - BigInt !== Number

- Symbol

  - 유일한 값을 만들어내기 위한 원시 타입
  - Symbol() 함수를 호출하여 생성
  - Symbol 함수는 호출될 때마다 새로운 값을 생성
  - Symbol 함수에 문자열을 전달하여 설명을 추가할 수 있다
  - 동일한 값을 사용하기 위해서는 Symbol.for() 함수를 사용한다

- 객체 타입
  - 참조를 전달한다고 해서 참조타입이라고 부르기도한다.

```
typeof [] === 'object' // true
typeof {} === 'object' // true

function hello(){}
typeof hello === 'function' // true

const hello1 = function(){}

const hello2 = function(){}

hello1 === hello2 // false

```

참조가 다르기때문에 false가 나온다.

- object.is()

  - 두 값이 같은지 비교하는 메서드
  - Object.is(0, -0) // false
  - 형변환 없이 값만 비교한다
  - 객체비교의 경우 다를것이 없다.

- shallowEqual
  - objectIs를 기반으로 구현된 함수
  - 의존성 비교
  - 동등 비교에 사용
  - objectIs로 비교 후 참조가 달라서 불가한 비교를 depth 1 까지만 수행
    - porps만 비교하면 되기때문에 얕은비교까지만 구현

따라서 또다른 객체를 넘겨준다면 랜더링이 불규칙하게 진행됨.

---

자바스크립트의 특징적인 객체 비교의 불완전성은 반드시 기억해야한다.
언어적인 한계로 이를 받아들이고 개발에 적용할 수 있도록 해야한다.

---

- 함수
  자바스크립트에서는 Components(props)형태 /
  리액트에서는

  ```
  <Components hello={props.hello} /> 혹은 <Components {...props} />
  형태로 스프레드 연산자로 사용한다는 차이가있다.
  ```

- 일급 객체이다
  다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체

- 호이스팅은 함수에 대한 선언을 메모리에 등록해놓는 작업이다.
  따라서 함수가 순차적으로 작성된것같은 느낌을 준다.

- function 생성자 함수를 사용하는것은 클로저생성 X, 가독성 감소, 성능저하
  따라서 함수 선언식을 사용하는것이 좋다.

- 화살표 함수

  - this 바인딩을 하지 않는다.
  - arguments 객체를 생성하지 않는다.

  ```
  const hello = () => {
    console.log(arguments)
  }
  hello(1,2,3) // error
  ```

  - new 연산자로 호출할 수 없다.
  - prototype 프로퍼티가 없다.
  - constructor 프로퍼티가 없다.

- this

  - 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
  - 함수가 호출될 때 결정된다.
  - 함수를 호출하는 방법에 따라 this에 바인딩될 값이 달라진다.
  - 함수가 일반 함수로 호출되면 this는 전역 객체에 바인딩된다.
  - 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.

- 화살표 함수와 일반 함수 내에서의 this 바인딩 차이

  - 화살표 함수 내에서의 this 바인딩은 상위 스코프의 this를 그대로 참조한다.
  - 일반 함수 내에서의 this 바인딩은 함수를 호출한 객체에 바인딩된다.
  - 화살표 함수가 단순 일반함수의 축약형이라고 생각하면 안된다.

- 즉시 실행 함수

  - 함수를 선언하자마자 즉시 실행되는 함수

  ```
  ((a,b)=>{return a+b},)(10,24) //34
  ```

  - 재호출이 불가하다.
  - 독립적인 스코프를 가진다.
  - 전역 스코프의 오염을 막을 수 있다.
  - 리팩토링에 도움이된다 읽는 사람이 함수가 한번만 호출된다는것을 알 수 있다.

- 고차 함수

  ```
  const doubledArray = [1,2,3].map((item)=>item*2)
  doubledArray // [2,4,6]

  const add = function(a){
    return function(b){
      return a+b
    }
  }

  add(1)(2) // 3
  ```

  - 함수를 인자로 받거나 함수를 반환하는 함수 생성 가능
  - 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할수있다.

- 함수의 부수 효과를 최대한 억제하는것이 좋다.

  - 부수효과 : 함수 내부에서 함수 외부의 상태를 변경하는것
  - 부수효과를 최대한 억제하면 함수의 의존성이 줄어들어 테스트와 유지보수가 쉬워진다.

- 함수는 가능한 작게 만들어내기

  - 함수는 한 가지 일만 해야한다.
  - 함수가 한 가지 이상의 일을 하게되면 함수를 재사용하기 어려워진다.

- 함수이름 함수가 어떤일을 하는지 알기쉽게 작성

- 클래스

  - 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 바로 클래스다.

  ```
  class Car{

    // constructor는 생성자이며 유일하다
    constructor(name){
      //값을 받으면 프로퍼티에 할당
      this.name = name
      }

  honk(){
    console.log(`${this.name} is honking`)
    }

  static hello(){
    console.log('저는 자동차입니다.')
    }

  set age(value){
    this.carAge = value
  }

  get age(){
    return this.carAge
  }

  const myCar = new Car('자동차') // 프로퍼티 값이 할당된다.

  myCar.honk()

  Car.hello()

  myCar.hello()

  myCar.age = 32

  console.log(myCar.age, myCar.carAge)}

  ```

- getter, setter는 프로퍼티에 접근할때 사용되는 메서드이다.
  - get을 앞에 붙여야하고 뒤이어 getter의 이름을 붙인다.

```
  class Car{


    constructor(name){

      this.name = name
      }

get firstCharacter(){
  return this.name[0]

  }
}
  const myCar = new Car('자동차')

  myCar.firstCharacter // '자'

```

- setter는 get과 마찬가지로 set을 붙여야하고 뒤이어 setter의 이름을 붙인다.
  - setter는 값을 할당할때 사용된다.

```

class Car{


    constructor(name){

      this.name = name
      }

get firstCharacter(){
  return this.name[0]

  }
}
  const myCar = new Car('자동차')

  myCar.firstCharacter // '자'

  myCar.firstCharacter = '차'

  console.log(myCar.firstCharacter, myCar.name) // '차', '차동차'

```

- 인스턴스 메서드와 정적 메서드

  - 인스턴스 메서드 : 인스턴스를 통해 호출하는 메서드

    - 프로토타입 확인하기

    ```
    object.getPrototypeOf(myCar)=== Car.prototype // Car

    myCar.__proto__ === Car.prototype // true
    ```

    - **proto**는 호환성을 유지하기위해서만 존재 사용하지않는것이 바람직함.

  - 정적 메서드 : 클래스를 통해 호출하는 메서드
    - 인스턴스를 통해 호출할 수 없다.
    - 클래스 내부에서 this를 사용할 수 없다.
    - 인스턴스를 생성하지 않아도 사용할 수 있다.
    - 생성하지 않아도 접근이 가능하다.
    - 여러곳에서 재사용이 가능하다.
    - 유틸리티 함수를 만들때 자주 활용된다.

- 클래스 상속

  - 클래스 상속은 부모 클래스의 프로퍼티와 메서드를 자식 클래스에서 사용할 수 있게 해준다.
  - extends 키워드를 사용하여 상속을 구현한다.
  - super 키워드를 사용하여 부모 클래스의 생성자를 호출한다.
  - super 키워드를 사용하여 부모 클래스의 메서드를 호출한다.
  - 자식 클래스에서 constructor를 구현할 때 super를 호출하지 않으면 에러가 발생한다.

- 클래스는 ES6에서 등장한 개념이다.

  - ES6이전에는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현했다.

- 클로저

  - 함수와 함수가 선언된 어휘적 환경의 조합
  - 함수가 생성될 당시의 외부 변수를 기억한다.
  - 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 클로저라고 한다.
  - 클로저는 함수를 값으로 다루는 자바스크립트의 고유한 특징을 가진다.
  - 코드가 작성된 순간에 정적으로 결정된다.

  - 스코프
    - 전역 스코프 : 코드의 모든 범위에서 접근 가능하다
    - 함수 스코프 : 함수 내부에서만 접근 가능하다

- 클로저의 활용

  - 함수형 프로그래밍
  - 정보은닉 // 함수의 내부에 있기에 가능

- 리액트에서의 클로저

  - 리액트에서는 클로저를 활용해 상태값을 안전하게 보호한다.
  - 리액트에서는 클로저를 활용해 이벤트 핸들러를 안전하게 보호한다.

- 클로저의 메모리 누수

  - 클로저는 외부 변수를 기억하므로 메모리 누수가 발생할 수 있다.
  - 클로저가 참조하는 외부 변수가 필요하지 않다면 null로 초기화하여 메모리 누수를 방지한다.

- 이벤트 루프 와 비동기 통신

  - 자바스크립트는 단일 스레드 기반의 언어이다.
  - 이벤트 루프는 자바스크립트의 비동기 처리 방식을 담당한다. // useEffect, setTimeout, setInterval
  - 이벤트 루프는 콜 스택과 태스크 큐를 사용해 비동기 처리를 구현한다.
  - 콜 스택은 함수 호출을 기록하는 자료구조이다.
  - 이벤트 루프는 콜 스택과 태스크 큐를 모니터링하며 콜 스택이 비어있을 때 태스크 큐의 함수를 콜 스택으로 이동시킨다.
  - 태스크 큐는 비동기 처리 함수의 콜백 함수를 대기시키는 자료구조이다.

- 태스크 큐와 마이크로태스크 큐

  - 태스크 큐는 콜 스택에 들어갈 함수를 대기시키는 자료구조이다.
  - 마이크로태스크 큐는 프로미스의 콜백 함수를 대기시키는 자료구조이다.
  - 마이크로태스크 큐의 우선순위가 더 높다.
  - 브라우저 렌터링은 마이크로태스크 큐와 테스크 큐 사이에서 발생한다.

- 구조 분해 할당

  - 객체나 배열을 분해하여 변수에 할당하는 것
  - 객체 구조 분해 할당
  - 배열 구조 분해 할당

    - 배열 구조 분해 할당은 순서대로 할당된다.
    - 객체 구조 분해 할당은 객체에서 값을 추출하여 변수에 할당한다.

  - 특정값 이후의 값을 배열로 받아오고 싶을때 ...rest를 사용한다. 스프레드 연산자를 앞에 사용하는것은 불가능하다.

- 스프레드 연산자

  - 배열의 전개 구문

  ```
  const arr = [1,2,3]
  const newArr = [...arr, 4,5,6]
  console.log(newArr) // [1,2,3,4,5,6]
  ```

  - 객체의 전개 구문

  ```
  const obj = {a:1, b:2}
  const newObj = {...obj, c:3, d:4}
  console.log(newObj) // {a:1, b:2, c:3, d:4}
  ```

- 전개구문 이후에 값이 있다면 뒤에있는 값이 덮어씌워진다.
- 전개구문 이전에 값이 있다면 전개구문이 해당값을 덮어쓴다

- 객체 초기자

  - 객체의 프로퍼티 이름과 값이 동일한 경우 프로퍼티 이름을 생략할 수 있다.
  - 객체 초기자를 사용하면 코드의 가독성이 높아진다.

  ```
  const a = 1
  const b = 2

  const ab = {a,b}
  console.log(ab) // {a:1, b:2}
  ```

- Array 프로토타입 메서드

  - Array.prototype.map()
    - 배열의 모든 요소에 대해 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.
    - 배열의 요소를 변형할 때 사용한다.
  - Array.prototype.filter()
    - 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환한다.
    - 배열의 요소를 걸러낼 때 사용한다.
    - 결과값 배열의 길이가 원본 배열의 길이 이하일 수 있다.
  - Array.prototype.reduce()
    - 배열의 각 요소에 대해 주어진 리듀서 함수를 실행하고 하나의 결과값을 반환한다.
    - 배열의 요소를 하나로 줄일 때 사용한다.
    ```
    const arr = [1,2,3,4,5]
    const sum = arr.reduce((acc, cur)=>acc+cur, 0) <- 0은 초기값
    // acc는 초기값의 현재값, 현재 배열의 요소
    console.log(sum) // 15
    ```
    - reduce는 초기값을 설정하지 않으면 배열의 첫번째 요소가 초기값이 된다.
    - reduce로 map 과 filter를 구현할 수 있지만 다소 코드가 복잡해지기 때문에 간단한 경우에만 사용하는것이 좋다.
  - Array.prototype.forEach()
    - 배열의 각 요소에 대해 주어진 함수를 실행한다.
    - 반환값이 없다.
    - 배열의 요소를 순회할 때 사용한다.
    - 프로세스를 종료하거나 에러를 던지지 않는이상 중단이 불가능하다.
    
- 삼항 조건 연산자
  
    - 조건식 ? 참일때 반환값 : 거짓일때 반환값
    - if문 대신 간단하게 사용하기 좋다
    - 중첩해서 사용하는것은 지양하는것이 좋다.

- TypeScript

  - 런타임에만 타입체크를 할 수 있는 한계를 극복해 안정성 확보와 버그를 줄이기 위해 사용한다.
  - 정적 타입 언어이다.
  - any 타입을 사용하면 타입스크립트의 장점을 활용할 수 없다.
  - unknown 타입은 any 타입과 달리 타입을 확정할 때까지 다른 타입으로 할당할 수 없다.
  - unknown은 top type이다.
  - never 타입은 절대 발생하지 않는 값의 타입을 나타낸다.
  - never 은 bottom type이다.
  
- 타입 가드
  - instanceof 와 typeof
  - 타입 가드를 사용하면 타입을 확정할 수 있다.
  - instanceof는 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인한다.
  - typeof는 변수의 타입을 확인한다.
  - in은 객체의 프로퍼티가 존재하는지 확인한다.
    - in을 활용해 타입에 여러가지 객체가 존재하는 경우를 대응할 수 있다.
  
- 제네릭
  - 타입을 인수로 받아서 사용하는 함수나 클래스를 의미한다.
  - 함수나 클래스를 작성할 때 타입을 명시하지 않고 사용할 때 사용한다.
  - 제네릭을 사용하면 재사용성이 높아진다.
  - 제네릭을 사용하면 타입을 명시하지 않아도 타입을 추론할 수 있다.

- 인덱스 시그니처
  - 인덱스 시그니처를 사용하면 키에 원하는 타입을 부여할 수 있다.
    - 객체의 키는 동적으로 선언되는것을 지양
    - 객체의 타입도 범위를 좁여햐 한다.

- 타입 단언
  - 타입 단언을 사용하면 타입스크립트에게 해당 값의 타입을 강제할 수 있다.
  - 타입 단언은 타입스크립트에게 해당 값의 타입을 확신할 때 사용한다.
  - 타입 단언은 타입스크립트의 타입 추론을 무시한다.
  - 타입 단언은 any 타입을 사용하는것과 유사하다.
  - 타입 단언은 타입스크립트의 타입 추론을 무시한다.  

- duck typing

  - 타입체크를 할때 그 값이 가진 형태에 집중

- 타입스크립트 전환 가이드

  - tsconfig.json 파일을 생성한다.
  - jsdoc @ ts-check을 사용해 타입스크립트의 타입 추론을 활용한다.
  - type 모듈 설치하기
  - 파일 단위로 조금씩 전환하기