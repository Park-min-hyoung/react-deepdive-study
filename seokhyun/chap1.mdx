---
title: 01장 정리
date: '2024/04/03'
description: 리액트 개발을 위해 꼭 알아야 할 자바스크립트
---

# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

- null 과 undefined

  - null : 의도적으로 값이 없음을 나타내는 값 : typeof : null -> object
  - undefined : 값이 할당되지 않은 상태 typeof : undefined -> undefined

- Boolean

  - falsy : false, 0, -0, 0n, "", null, undefined, NaN
  - truthy : falsy를 제외한 모든 값
    - 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다

- Number

  - BigInt : 큰 정수를 표현하기 위한 자바스크립트의 새로운 원시 타입
    - 숫자 뒤에 n을 붙여서 생성한다
    - typeof : bigint
      - BigInt !== Number

- Symbol

  - 유일한 값을 만들어내기 위한 원시 타입
  - Symbol() 함수를 호출하여 생성
  - Symbol 함수는 호출될 때마다 새로운 값을 생성
  - Symbol 함수에 문자열을 전달하여 설명을 추가할 수 있다
  - 동일한 값을 사용하기 위해서는 Symbol.for() 함수를 사용한다

- 객체 타입
  - 참조를 전달한다고 해서 참조타입이라고 부르기도한다.

```
typeof [] === 'object' // true
typeof {} === 'object' // true

function hello(){}
typeof hello === 'function' // true

const hello1 = function(){}

const hello2 = function(){}

hello1 === hello2 // false

```

참조가 다르기때문에 false가 나온다.

- object.is()

  - 두 값이 같은지 비교하는 메서드
  - Object.is(0, -0) // false
  - 형변환 없이 값만 비교한다
  - 객체비교의 경우 다를것이 없다.

- shallowEqual
  - objectIs를 기반으로 구현된 함수
  - 의존성 비교
  - 동등 비교에 사용
  - objectIs로 비교 후 참조가 달라서 불가한 비교를 depth 1 까지만 수행
    - porps만 비교하면 되기때문에 얕은비교까지만 구현

따라서 또다른 객체를 넘겨준다면 랜더링이 불규칙하게 진행됨.

---

자바스크립트의 특징적인 객체 비교의 불완전성은 반드시 기억해야한다.
언어적인 한계로 이를 받아들이고 개발에 적용할 수 있도록 해야한다.

---

- 함수
  자바스크립트에서는 Components(props)형태 /
  리액트에서는

  ```
  <Components hello={props.hello} /> 혹은 <Components {...props} />
  형태로 스프레드 연산자로 사용한다는 차이가있다.
  ```

- 일급 객체이다
  다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체

- 호이스팅은 함수에 대한 선언을 메모리에 등록해놓는 작업이다.
  따라서 함수가 순차적으로 작성된것같은 느낌을 준다.

- function 생성자 함수를 사용하는것은 클로저생성 X, 가독성 감소, 성능저하
  따라서 함수 선언식을 사용하는것이 좋다.

- 화살표 함수
  - this 바인딩을 하지 않는다.
  - arguments 객체를 생성하지 않는다.
  - new 연산자로 호출할 수 없다.
  - prototype 프로퍼티가 없다.
  - constructor 프로퍼티가 없다.

```

```
