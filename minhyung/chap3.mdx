---
title: 03장 정리
date: "2024/04/16"
description: 리액트 훅 깊게 살펴보기
---

## 리액트의 모든 훅 파헤치기

- 훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만듬
- 클래스 컴포넌트보다 간격할게 작성할 수 있어 훅이 등장한 이래로 대부분의 리액트 컴포넌트는 함수 컴포넌트로 작성

1. useState

- 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅

```
import {useState} from 'react'

const [state, setState] = useState(initialState)
```

- 리액트는 클로저를 이용해 useState를 구현했다.
- 게으른 초기화

  - useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
  - 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용

  ```
  const [state, setState] = useState(() => {
      // App 컴포넌트가 처음 구동될 때만 실행되고, 이후 리렌더링 시에는 실행되지 않는다.
      console.log("복잡한 연산")

      return 0
  })
  ```

2. useEffect

- 앺프리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘
- 부수 효과가 '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는것이 중요하다.

```
useEffect(() => {
    ...
}, [props, state])
```

- usEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값을 변화를 관찰하는 것이 아니다.
- 렌러딩할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 평범한 함수
- 즉, useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.
- 클린업 함수의 목적
  - 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행되고
  - 함수 컴포넌트의 useEffect는 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.
  - 따라서, 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제할 수 있다.
  - 클린업 함수는 생명주기 메서드의 언마운트 개념과는 조금 차이가 있다. 언마운트는 특정 컴포넌트가 DOM에서 사라진다는 것을 의미하지만 클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링 되었을 때 의존성 변화가 있을 당시 이전의 값을 기준으로 실행되는, 말 그대로 **이전 상태를 청소해주는 개념**
- 의존성 배열
  - 의존성 배열이 없는 경우
  - 의존성 배열이 빈 배열인 경우
  - 의존성 배열이 특정 데이터가 있는 경우
- useEffect를 사용할 때 주의할 점
  - useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행되야하는 훅이다.
- 꿀팁
  - usEffect의 첫 번째 인수에 함수명을 부여하라
  - 거대한 useEffect를 만들지 마라
  - 불필요한 외부 함수를 만들지 마라
- 왜 useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없을까?
  - 이전 state 기반 패치 시간은 10초, 현재 state를 기반 패치 시간은 1초라면
  - 1초 후 현재 state 기반으로 상태를 업데이트하고 10초 후 이전 state를 기반으로 상태를 업데이트
  - 이로인해 이전 state에 해당하는 서버 데이터를 상태로 관리하게되는 문제가 발생한다.

3. useMemo

- 비용이 큰 연산에 대한 결과를 저장해두고, 이 저장된 값을 반환하는 훅
- useMemo를 사용해 컴포넌트도 메모이제이션해서 사용한다.

```
const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b])
```

4. useCallback

- useMemo가 값을 기억했다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다.
- 특정 함수를 새로 만들지 않고 다시 재사용

5. useRef

- useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다. 그러나 useState와 구별되는 큰 차이점 두가지를 가지고 있다.
  - useRef는 반환값이 ㄴ객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
  - useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.
- useRef가 필요한 이유
  - value라는 일반 변수를 사용할 경우 컴포넌트가 실행되어 렌더링되지 않았음에도 value라는 값이 기본적으로 존재하게 되고 이로 인해 메모리에 불필요한 값을 갖게하는 악영향을 미친다.
  - 컴포넌트가 여러 번 생성된다면 각 컴포넌트에서 가리키는 값이 모두 value로 동일하게 된다. 컴포넌트 인스턴스 하나당 하나의 값을 필요로 하는 것이 일반적

6. useContext

- Context: props drilling을 극복하기 위해 등장한 개념
- useContext는 상위 컴포넌트에서 만들어진 Context를 함수 컴포넌트에서 사용할 수 있도록 만들어진 훅이다.
- createContext, Context.Provider, useContext

7. useReducer

- useState의 심화버전으로 useState와 비슷한 형태를 띠지만 좀 더 복잡한 상태값을 미리 정의해 놓은 시나리오에 따라 관리할 수 있다.
- 요소
  - reducer: useReducer의 기본 action을 정의하는 함수다. 이 reducer는 useReducer의 첫번째 인수로 넘겨주어야한다.
  - initialState: 두 번째 인수로, useReducer의 초기값을 의미한다.
  - init: useState의 인수로 함수를 넘겨줄 때 처럼 초기값을 지연해서 생성시키고 싶을 때 사용하는 함수다. 이 함수는 필수값이 아니며, 만약 여기에 인수로 넘겨주는 ㅎ마수가 존재한다면 useState와 동일하게 게으른 쵝화가 일어나며 InitialState를 인수로 init함수가 실행된다.

8. useImperativeHandle

- forwardRef
  - 상위 컴포넌트에 ref라는 이름의 props를 사용하게 되면 경고문이 나오고 접근 시 undefined를 반환하게 된다.
  - forwardRef는 ref를 전달하는데 있어 일관성을 제공하기 위해서이다.
  - 네이밍의 자유가 주어진 props보다는 forwardRef를 사용하면 좀 더 확실하게 ref를 전달할 것임을 예측할 수 있고, 또 사용하는 쪽에서도 확실히 안정적으로 받아서 사용할 수 있다.(상위 컴포넌트에서 ref props명을 사용해도 경고문이 안뜸)
- useImperativeHandle은 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅

```
const ChildComponent = forwardRef((props, ref) => return (<div>안녕</div>))
```

9. useLayoutEffect

- DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때만 사용하기를 권장

10. useDebugValue

- 리액트 애플리케이션을 개발하는 과정에서 사용되는데, 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다.

11. 훅의 규칙

- 최상위에서만 훅을 호출해야한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
- 훅은 호출할 수 있는 것은 리액트 함수 컴포넌트, 혹은 사용자 정의 훅의 두 가지 경우뿐이다. 일반 자바스크립트 함수에는 훅을 사용할 수 없다.
- 훅에 대한 정보 저장은 리액트 어딘가에 있는 index와 같은 키를 기반으로 구현돼있다.(실제로는 객체 기반 링크드 리스트에 더 가깝다.)

12. 정리

- 훅의 작동 방식을 제대로 이해하고 사용하는 것이 더욱 짜임새 있는 리액트 애플리케이션 개발에 도움이된다.
- 훅은 함수 컴포넌트의 렌더링에도 많은 영향을 미치기 때문에 성능적으로 뛰어난 리액트 애플리케이션을 작성하려면 훅에 대해 정확히 이해해야한다.

## 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

1. 사용자 정의 훅

- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용되는 것
- 고차 컴포넌트는 굳이 리액트가 아니더라도 사용할 수 있는 기법이지만 사용자 정의 훅은 리액트에서만 사용할 수 있는 방식

2. 고차 커포넌트

- 컴포넌트 자체의 로직을 재사용하기 위한 방법
- 사용자 정의 훅은 리액트 훅을 기반으로 하므로 리액트에서만 사용할 수 있는 기술
- 고차 컴포넌트는 고차 함수의 일종으로, 자바스크립트 일급 객체, 함수의 특징을 이용하므로 굳이 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있다.
- 가장 유명한 고차 컴포넌트 React.memo

3. 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

- 사용자 정의 훅이 필요한 경우

  - 단순히 useEffect, useState와 같이 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다.
  - 사용자 정의 훅은 그 자체로는 렌더링에 영향을 미치지 못하기 때문에 사용이 제한적이므로 반환하는 값을 바탕으로 무엇을 할지는 개발자에게 달려 있다.
  - 컴포넌트 내부에 미치는 영향을 최소하해 개발자가 훅을 원하는 방향으로만 사용할 수 있다는 장점이 있다.

- 고차 컴포넌트를 사용해야하는 경우
  - 함수 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트 사용하는 것이 좋다.
  - 고차 컴포넌트는 이처럼 공통화된 렌더링 로직을 처리하기에 매우 훌륭한 방법이다.
  - 단, 고차 컴포넌트가 많아질수록 복잡성이 기하급수적으로 증가하므로 신중하게 사용해야한다.

4. 정리

- 공통화하고 싶은 작업이 무엇인지, 또 현재 이를 처리해야하는 상황을 잘 살펴보고 적절한 방법을 고른다면 애플리케이션 개발이 더 효율적으로 개선될 것이다.
