---
title: 02장 정리
date: "2024/04/10"
description: 리액트 핵심요소 깊게 살펴보기
---

## JSX란?

1. JSX의 정의

- JSXElement, JSXAttributes, JSXChildren, JSXString라는 4자기 컴포넌트를 기반으로 구성돼있다.
- JSXElement
  - JSX를 구성하는 가장 기본 요소로, HTML의 요소와 비슷한 역할을 한다.
  - JSXOpeningElement, JSXClosingElement, JSXSelfClosingElement, JSXFragment
- JSXElementName
  - JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다.
  - JSXIdentifier를 주로 사용한다.
  ```js
  function() {
    return <A></A>
  }
  ```
- JSXAttributes

  - JSXElement에 부여할 수 있는 속성
  - 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않는다.
  - JSXSpreadAttributes: 자바스크립트의 전개 연산자와 동일한 역할을 한다고 볼 수 있다.

  ```
  const person = {
    name: 'John',
    age: 30,
    city: 'New York'
  };

  <MyComponent {...person} />
  ```

  - JSXAttribute: 속성의 key 값을 나타내는 JSXAttributeName과 속성의 키에 할당 할 수 있는 값을 나타내는 JSXAttributeValue로 구성

  ```
  function Child({attribute}) {
    return <div>{attribute}</div>
  }

  export default function App() {
    return (
      <div>
        <Child attribute=<div>hello</div> />
      </div>
    )
  }
  ```

- JSXChildren
  - JSXElement의 자식 값을 나타낸다.
- JSXStrings

2. JSX 예제

```
// 하나의 요소로 구성된 가장 단순한 형태
const CompoA = <A>안녕</A>

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태
const CompoB = <B/>

// 옵션을 {}와 전개 연산자로 넣을 수 있다.
const CompoC = <C {...{required: true}} />

// 속성만 넣어도 가능
const CompoD = <D required />

// 속성과 속성값을 넣을 수 있다.
const CompoE = <E required={false} />

// 문자열은 큰따옴표 및 작은따옴표 모두 가능하다.
const CompF =
  <A>
    <B text="안녕" />
  </A>

// 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법이다.
const CompG =
  <A>
    <B optionChildren={<div>하위 컴포넌트 안녕</div>} />
  </A>

// 여러개의 자식도 포함
const CompH =
  <A>
    <B optionChildren={<div>하위 컴포넌트 안녕</div>} />
    <div>wow</div>
  </A>
```

3. JSX는 어떻게 자바스크립트에서 변환될까?

- 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인에 의해 변한다.
- JSX 반환값이 결국 React.createElement로 귀결된다.

4. 정리

- JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에 각광
- 리액트 내부에서 JSX가 어떻게 변환되는지, 그리고 어떤 결과물을 만들어내는지 알아두면 향후에 리액트 애플리케이션을 만드는데 도움이 될 수 있다.

## 가상 DOM과 리액트 파이버

1. DOM과 브라우저 렌더링 과정

- 브라우저 렌더링 절차

1.  브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드
2.  브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)을 만든다.
3.  2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4.  브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)을 만든다.
5.  브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none와 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6.  5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.

- 레이아웃: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 고자ㅓㅇ도 거치게 된다.
- 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

2. 가상 DOM의 탄생 배경

- 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다.
- 대다수 앱은 렌더링된 이후 정보를 보여주는데 그치지 않고 사용자의 인터랙션을 통해 다양한 정보를 노출한다.
- 사용자의 인터랙션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자 입장에서 너무나 수고스러운일이다.
- 인터렉션에 모든 DOM의 변경보다는 결과적으로 만들어지는 DOM 결과물 하나만 알고 싶을 것이고 최종 결과물을 간편하게 제공하는 것이 브라우저뿐만 아니라 개발자에게 매우 유용하다.

## 렌더링은 어떻게 일어나는가?

1. 리액트 렌더링이란

- 렌더링은 브라우저에서도 사용하는 용어이므로 두 가지를 혼동해서 사용해서는 안된다.
- 리액트에서의 렌더링이란 리액트 애플리케이션의 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state를 기반으로 어떤게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

2. 리액트의 렌더링이 일어나는 이유

- 최조 렌더링: 사용자가 처음 앱에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리엑트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
- 리랜더링: 처음 앱에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다
- 리렌더링이 발생하는 경우
  - 클래스 컴포넌트으의 setState가 실행되는 경우
  - 클래스 컴포넌트의 forceUpdate가 실행되는 경우
  - 함수 컴포넌트의 useState()의 두번째 배열 요소인 setter가 실행되는 경우
  - 함수 컴포넌트의 useReducer()의 두번째 배열 요소인 dispatch가 실행되는 경우
  - 컴포넌트의 key props가 변경되는 경우
  - props가 변경되는 경우
  - 부모 컴포넌트가 렌더링될 경우에서

3. 리엑트의 렌더링 프로세스

- 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
- 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스 컴포넌트의 경우에는 클래스 내부의 render() 함수를 실행하고, 함수 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에, 그 결과물을 저장한다.
- 렌더링 결과물은 JSX 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환된다.
- createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다.

```
function Hello() {
  return (
    <TestCompo a={35} b="park">
      안녕하세요
    </TestCompo>
  )
}

// 위 JSX 문법은 React.createElment를 통해 호출해서 변환
function Hello() {
  return React.createElment(
    TestCompo,
    {a: 45, b: 'park'},
    '안녕하세요',
  )
}

// 결과물
{type: TestCompo, props: {a: 35, b:'park', children: '안녕하세요'}}
```

4. 렌더와 커밋

- 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
  - 렌더링 프로세스에서 컴포넌트를 싱행해(reder() or return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
  - 이 과정엣 비교하는 것은 크게 세가지로, type, props, key(이 세가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해둔다.)
- 커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
  - 해당 단계야 끝나야 비로소 브라우저의 렌더링이 발생한다.
  - 리액트가 먼저 실제 DOM을 커밋 단계에서 업데이트
  - 이렇게 만들어진 모든 실제 DOM의 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.
  - 그다음, 생명주기 개념이 있는 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수 컴포넌트에서는 useLayoutEffect 훅을 호출한다.
- 중요한 사실을 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것
  - 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략 가능
  - 즉 리액트의 렌더링은 꼭 가시적인 변경이 일너나지 않아도 발생할 수 있따.
  - 렌더링 과정 중 첫 먼째 단계인 렌더 단계에서 변경 사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

5. 정리

- 리액트에서 일어나는 렌더링 시나리오를 정확히 이해한다면 컴포넌트의 트리 구조를 개선하거나 불필요한 렌더링 횟수를 줄임
- 이로써 성능 좋은 리액트 웹 애플리케이션을 만드는데 많은 도움이 된다.

## 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

1. 주장1: 섣부른 최적하는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- 이전 값과 현재 값을 비교해 렌더링 또는 재계산이 필요한지 확인 하는 작업, 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.
- 위의 비용이 리렌더링 비용보다 저렴한지 고려해봤을 때 항상 그렇다고 말할 수 없다.
- 메모이제이션은 트레이드오프가 있다.

2. 주장2 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션 하자.

- 렌더링이 자주 일어나거나 해당 컴포넌트의 비싼 연산이 포함되어있다고 자식 컴포넌트에서도 해당 상황이 일어나면 메모이제이션 하는것이 효율적이다.
- 컴포넌트의 상황에 따라 일부 적용 vs 일단 다 적용(전자가 이상적임)
- 평소 업무를 진행하면서 전자의 기조를 가지고 개발하기에는 쉽지 않은것이 현실이다.
- 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장하고 있다. 그것이 기본적인 리액트 재조정 알고리즘이기 때문이다. 즉, 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물을 저장하고 있기 때문에 memo로(React.memo) 지불해야 하는 비용은 props에 대한 얕은 비교뿐(해당 비용도 무시 못하긴함)
- memo를 하지 않았을 때 비용
  - 렌더링을 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 그리고 위 두 가지 모두가 자식 컴포넌트에서 반복해서 일어남
  - 리액트가 구 트리와 신규 트리를 비교뿐
- useMemo와 useCallback
  - 리렌더링이 발생할 때 메모제이션과 같은 별도 조치가 없다면 객체는 재생성, 즉 이전 참조와 다른 새로운 참조
  - 새로운 참조를 하위 컴포넌트나 useEffect에서 사용하게 된다면 해당 참조를 가지고 있는 식별자의 값이 수정되지 않아도 컴포넌트가 리렌더링되는 문제가 발생한다.(참조 투명성을 유지할 수 없다.)

3. 결론 및 정리

- 시간적인 여유가 있고 최적화를 위해 시간을 투자할 생각이 있다면 부분적으로 최적하는 것이 좋다.
- 당장 시간적인 여유가 없는 경우에는 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장
