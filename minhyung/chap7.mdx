---
title: 07장 정리
date: "2024/05/16"
description: 좋은 리액트 코드 작성을 위한 환경 구축하기
---

## ESLint를 활요한 정적 코드 분석

1. ESLint 살펴보기

- ESLint 코드 분석 과정
  1. 자바스크립트 코드를 문자열로 읽는다.
  2. 자바스크립트 코드를 분석할 수 있는 파서로 코드를 구조화한다.
  3. 2번에서 구조화한 트리를 AST라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.
  4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나 수정한다.

2. eslint-plugin과 eslint-config

- eslint-plugin
  - 규칙을 모아놓은 패키지. ex) eslint-plugin-import(자바스크립트에서 다른 모듈을 불러는 import와 관련된 다양한 규칙을 제공)
  - eslint-plugin-React
- eslint-config
  - eslint-plugin이 리액트, import와 같이 특정 프레임워크나 도메인과 관련된 규칙을 묶어서 제공하는 패키지라면 eslint-config는 이러한 eslint-plugin을 한데 묶어서 완벽하게 한 세트로 제공하는 패키지
- eslint-config-airbnb
  - 리액트 기반 프로젝트에서 eslint-config를 선택 한다고 가정했을 때 가장 먼저 손에 꼽는 eslint-config
- @titicaca/triple-config-kit
  - 한국 커뮤니티에서 운영되는 eslint-config 중 유지보수가 활발한 편에 속하며, 많이 쓰이는 eslint-conf 중 하나
- ESLint뿐만 아니라 Prettier와 Stylelint를 각각 별도의 룰인 @titicaca/prettier-config-triple, @titicaca/stylelint-config-triple로 모노로페로를 만들어 관리하고 있어 Prettier나 Stylelint도 필요에 따라 설치해서 사용할 수 있다.
- eslint-config-next
  - 리액트 기반 Next.js 프레임워크를 사용하고 있는 프로젝트에서 사용할 수 있는 eslint-config
  - 자바스크립트 코드 뿐만 아니라 페이지나 컴포넌트에서 반환하는 JSX 구문 및 \_app, \_document에서 작성돼 있는 HTML 코드 또한 정적 분석 대상으로 분류해 제공한다.

3. 나만의 ESLint 규칙 만들기

- 이미 존재하는 규칙을 커스터마이징해서 적용하기: import React를 제거하기 위한 ESLint 규칙 만들기
  - p.481, p.482
- 완전히 새로운 규칙 만들기: new Date를 금지시키는 규칙
  - p.484 ~ p.486
  - 규칙은 하나씩 만들어 배포하는 것은 불가능하며, 반드시 eslint-plugin 형태로 규칙을 묶음으로 배포하는 것만 가능하다.(p.487 ~ p.489)

4. 주의할 점

- ESLint는 함번 잘 성정해두면 코딩하는 내내 융ㅇ하게 활용할 수 있지만 잘못 설정해두면 원치 않는 결고가가 계속해서 발생하게 된다.
- Prettier와의 충돌
  - ESLint는 코드의 잠재적인 문제가 될 수 있는 부분을 분석해 준다면, Prettier는 포매팅과 관련된 작업, 즉 줄바꿈, 들여쓰기, 작은따옴표와 큰따옴표 등을 담당한다.
  - 자바스크립트에서만 작동하는 ESLint와 다르게, Prettier는 자바스크립트뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에도 적용 가능하다.
  - 하지만 ESLint에서도 Prettier에서 처리하는 자겅ㅂ(들여쓰기, 줄바꾸, 따옴표, 최대글자수)을 처리할 수 있기 때문에 두 가지 모두를 자바스크립트 코드에서 실행한다면 서로 충돌하는 규칙으로 인해 에러가 발생하고, 최악의 경우 둘 다 만족하지 못하는 코드가 만들어질 수 있다.
  - 충돌을 막기 위한 방법
    1. Prettier에서 제공하는 규칙을 어기지 않도록, ESLint에서는 해당 규칙을 끄는 방법. 이 경우에 코드에 ESLint를 적용하는 작업과 코드의 포매팅을 하는 작업이 서로 다른 패키지에서 발생하게 된다.
    2. JS, TS는 ESLint, 그 외의 파일(마크다운, JSON)은 모두 Prettier에게 맡기는 방법. 그 대신 자바스크립트에 추가적으로 필요한 Prettie 관련 규칙은 모두 eslint-plugin-prettier를 사용(eslint-plugin-prettier는 Prettier에서 제공하는 모든 규칙을 ESLint에서 사용할 수 있는 규칙으로 만들어둔 플러그인)
- 규칙에 ㅔ대한 예외 처리, 그리고 react-hooks/no-exhaustive-deps
  - 만약 일부 코드에서 특정 규칙을 임시로 제외시키고 싶다면 eslint-disable- 주석을 사용하면 도니다.
  - eslint-disable-line no-exhaustive-deps
    - useEffectsk useMemo와 같이 의존 배열이 필요한 훅에 의존성 배열을 제대로 선언했는지 확인하는 규칙을 무시할 수 있다. 하지만 이 규칙은 버그를 발생 시킬 위험이 있기 때문에 아래 3가지를 고려해 최대한 사용을 지양해야한다.
      1. 괜찮다고 임의로 판단한 경우: 가장 위험한 경우. 실제로 면밀히 검토해서 괜찮은 경우라면 해당 변수는 컴포넌트의 상태와 별개로 동작한다는 것을 의미한다. 이 경우에는 해당 변수를 어디서 어떻게 선언할지 다시 고민해 봐야 한다. 정말로 괜찮다 하더라도 이러한 작업이 반복되면 정말로 괜찮지 않은 코드에서도 동일하게 사용해 버그를 야기할 위험이 있다.
      2. 의존성 배열이 너무 긴 경우: 의존성 배열이 너무 길다는 것은 UseEffect 내부 함수가 너무 길다는 말과 동일하다. useEffect가 너무 길다면 UseEffect를 쪼개서 의존성 배열의 가독성과 안정성을 확보해야한다.
      3. 마운트 시점에 한 번만 실행하고 싶은 경우: 가장 흔히 볼 수 있는 경우로, 의도적으로 []로 모든 의존성을 제거해 컴포넌트가 마운트되는 시점에만 실행하고 싶은 경우다. 먼저 이러한 접근 방법은 과거 클래스 컴포넌트에서 사용되던 생명주기 형태의 접근 방버으로, 함수 컴포넌트의 패러타임과는 맞지 않을 가능성이 있다. 또한 [] 배열이 있다는 것은 컴포넌트의 상태값과 별개의 부수 효과가 되어 컴포넌트의 상태와 불일치가 일어날 수 있게 된다. 마지막으로, 상태와 관계없이 한 번만 실행되야 하는 것이 있다면 해당 컴포넌트에 존재할 이유가 없다. 이 경우 적절한 위치로 옮기는 것이 옳다.
- ESLint와 버전 충돌
  - ESLint간 버전 충돌이 발생할 수 있으므로 공식문서에서도 ESLint를 peerDependencies로 설정해 두라고 권장
  - 이러한 ㅜㄴㅈ를 미연에 방지하려면 설치하고자 하는 eslint-config, eslint-plugin이 지원하는 ESLint 버전을 확인하고, 또 설치하고자 하는 프로젝트에서 ESLint 버전을 어떻게 지원하고 있는지 살펴봐야한다.
  - 두 ESLint 버전을 모두 충족시킬 수 있는 환경을 만들어두고 설치하는 것이 좋다. 만약 이러한 사전 준비를 제대로 하지 않는다면 ESLint를 사용할때마다 버전이 맞지 않는다는 오류 메시지를 마주하게 될 것이다.

5. 정리

- 프로젝트에 설치돼 있는 eslint-config는 무엇인지, 왜 이것을 문제가 있는 코드로 간주하는지 반드시 한 번씩 살펴봐야한다.
- 모든 규칙에는 그것이 존재하는 이유가 있고, 그러한 이유로 많은 개발자들에게 인정받고 설치되어 Npm으로 업로드되어 있는 것

## 리액트 팀이 권장하는 리액트 테스트 라이브러리

1. React Testing Library란?

- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리로, 리액트를 기반으로 한 테스트를 수행하기 위해 만들어졌다.
- DOM Testing Library는 jsdom을 기반으로 하고있다. jsdom이란 순수하게 자바스크립트로 작성된 라이브러리로, HTML이 없는 자바스크립트만 존재하는 환경, 예를 들어 Node.js 같은 환경에서 HTML과 DOM을 사용할 수 있도록 해주는 라이브러리다.
- jsdom을 사용해 자바스크립트 환경에서 HTML을 사용할 수 있는 DOM Testing Libarary를 기반으로, 동일한 원리로 리액트 기반 환경에서 리액트 컴포넌트를 테스팅할 수 있는 라이브러리가 바로 리액트 테스팅 라이브러리

2. 자바스크립트 테스트의 기초

- jest와 같은 테스트 프레임워크를 사용하면 무엇을 테스트했는지, 소용된 시간은 어느정도 인지, 무엇이성공하고 실패했는지, 전체 결과는 어떤지에 대한 자세한 정보를 확인할 수 있다.
- 어셜선 라이브러리를 내장한 테스트 프레임워크를 사용하면 테스트 코드를 작성하는 것뿐만 아니라 테스트에 대한 결과와 관련 정보를 일목요연하게 확인할 수 있다.

3. 리액트 컴포넌트 테스트 코드 작성하기

- 리액트 컴포넌트 테스트 순서
  1. 컴포넌트를 렌더링한다.
  2. 필요하다면 컴포넌트에서 특정 액션을 수행한다.
  3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다.
- 프로젝트 생성
  - p.501 ~ p.503
  - HTML 요소를 찾는 법
    - getBy...: 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러를 발생시킨다. 복수 개를 찾고 싶다면 getAllBy..를 사용하면 된다.
    - findBy...: getBY...와 거의 유사하나 한 가지 큰 차이점은 Promise를 반환한다는 것이다. 즉, 비동기로 찾는다는 것을 의미하며, 기본값으로 1000ms의 타입 아웃을 가지고 있다. 마찬가지로 두 개 이상이면 에러를 발생시키지만 복수개를 찾고 싶다면 findAllby...를 사용하면 된다. 이러한 특징 때문에 findBy는 비동기 액션 이후에 요소를 찾을 때 사용
    - queryBy...: 인수의 조건에 맞는 요소를 반환하는 대신, 찾지 못한다면 null을 반환한다. getBY, findBy는 찾지 못하면 에러를 발생시키 때문에 찾지 못해도 에러를 발생시키지 않고 싶다면 queryBy를 사용하면 된다. 마찬가지로 복수 개를 찾았을 때는 에러를 발생시키며, 복수 개를 찾고 싶다면 queryByall을 사용
- 정적 컴포넌트
  - p.503 ~ p.506
  - jest 메서드
    - beforeEach: 각 테스트(it)을 수행하기 전에 실행하는 함수
    - describe
    - it
    - testId: 리액트 테스팅 라이브러리의 예약어로, get 등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용할 수 있따. HTML의 DOM 요소에 testId 데이터 셋을 선언해 두면 이후 테스트 시에 getByTestId, findByTestId 등으로 선택할 수 있다. 웹에서 사용하는 qeurySelector([data-testid=$])와 동일한 역할
- 동적 컴포넌트
  - 사용자가 useState를 통해 입력을 변경하는 컴포넌트
    - p.509 ~ p.512
    - 메서드
      - setup: 내부에서 컴포넌트를 렌더링하고, 또 테스트에 필요한 button과 input을 반환한다. 이 파일에서 수행하는 모든 테스트는 렌더링과 button, input을 필요로 하므로 이를 하나의 함수로 묶는데 사용
      - userEvent.type: 사용자가 타이핑 하는 것을 흉내내는 메서드. 기본적으로 userEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내 낸다. 예를 들어, userEvent.click을 수행하면 내부적으로 다음과 같은 fireEvent가 수행된다(fireEvent.(mouseOver, mouseMover, mouseDown, mouseUp, click))
      - jest.spyOn: jest가 제공하는 spyOn은 어떠한 특정 메서드를 오명시키지 않고 싱행이 됐는지 또, 어떤 인수로 실행했는지 등 실행과 관련된 정보만 얻고 싶을 때 사용한다.
      - mockIMplementation: 해당 메서드에 대한 모킹 구현을 도와준다. 현재 jest를 실행하는 Node.js 환경에서는 window 객체의 프로퍼티(alert)가 존재하지 않으므로 해당 메서드를 모의 함수로 구현해야하는데, 이것이 바로 이 메서드의 역할이다. 비록 모의 함수로 구현된 함수이지만 함수가 실행됐는지 등의 정보는 확인할 수 있도록 도와준다.
  - 비동기 이벤트가 발생하는 컴포넌트
    - p.516 ~ p.519
    - MSW 사용해 요청을 가로채 fetch 응답을 모킹

4. 사용자 정의 훅 테스트 하기

- react-hooks-testing-libray를 사용하면 훅을 더욱 편리하게 테스트할 수 있다.
- useEffectDebugger Hook 테스팅
  - p.520 ~ p.526

5. 테스트를 작성하기에 앞서 고려해야 할 것

- 테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니다. 그러므로 절대 테스트 커버리지를 맹신해서는 안된다.
- 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 `애플리케이션에 가장 취약하거나 중요한 부분을 파악하는 것`
  - 중요 기능과 연관되어 테스트가 필요한 코드를 파악해야한다.
  - 그리고 해당 코드들이 어떻게 순차적으로 실행되는지 확인한 다음, 그 순차적인 프로세스에 맞춰 테스트 코드를 작성하면된다.
  - 이 테스트가 통과해야할 테스트 코드는 반드시 사용자의 작업과 최대한 유사하게 작성돼야 한다.
  - 예를 들어, 결제를 위해 사용자가 입력하는 절차, 장바구니, 주소 입력, 결제까지의 과정을 모두 사용자와 최대한 비슷한 입장에서 테스트를 작성하는 것이 필요
- 애플리켕션에서 가장 핵심이 되는 부분부터 먼저 테스트 코드를 작성해 나가는 것이 중요하다.
- 테스트 코드는 소프트트웨어의 코드를 100% 커버하기 위해, 혹은 테스트 코드가 모두 그린 사인(테스트가 모두 통과)을 보기 위해 작성하는 것이아니다.
- 테스트 코드는 개발자가 단순 코드 작성만으로는 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확신을 얻기 위해 작성하는 것이다.

6. 그 밖에 해볼 만한 여러 가지 테스트

- 테스트 종류
  - 유닛 테스트: 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도도니 대로 정확히 작동하는지 검증하는 테스트
  - 통합 테스트: 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
  - E2E 테스트: 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트

7. 정리

- 테스트가 이뤄야 하는 목표는 `애플리케이션이 비즈니스 요구사항을 충족하는지 확인`하는 것 한가지뿐이다.
- 조금씩, 그러나 핵심적인 부분부터 테스트 코드를 작성하다 보면 소프트웨어의 품질에 확신을 가질 수 있다.
