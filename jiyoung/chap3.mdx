---
title: 03장 정리
date: "2024/04/15"
description: 리액트 훅 깊게 살펴보기
---

## 리액트의 모든 훅 파헤치기

### useState

- useState는 함수 컴포넌트에서 상태를 관리할 수 있게 해주는 훅이다.
- useState는 배열을 반환하며 첫 번째 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수이다.

#### useState 구현 살펴보기

```bash
function Component() {
    let state = 'Hello';
    function handleButtonClick() {
        state = 'World';
        console.log(state);
    }
  return (
    <div>
      <p>{state}</p>
      <button onClick={() => handleButtonClick}>hi</button>
    </div>
  );
}
```

- 위 코드는 버튼을 클릭했을 때 state가 'World'로 변경되는 것을 기대하지만, 실제로는 'Hello'로 출력된다.
- **함수 컴포넌트는 매번 함수를 실행해 렌더링**이 일어나고, **함수 내부의 값은 함수가 실행될 때마다 다시 초기화** 한다.
- useState 내부에 선언된 함수 setState가 함수의 실행이 종료된 이후(useState가 호출된 이후)에도 지역변수인 state를 계속 참조할 수 있다. (클로저)

#### 게으른 초기화

- useState의 초기값은 함수로 지정할 수 있다.

```bash
const [counter, setCounter] = useState(() => {
  Number.parseInt(localStorage.getItem('count') || 0);
});
```

- 위 코드는 컴포넌트가 렌더링될 때마다 localStorage를 조회하는 것이 아니라, **최초 렌더링 시에만 조회**한다.
- 무거운 연산이 필요한 초기값을 지정할 때 사용하면 좋다.
- `localStorage`, `sessionStorage`, `map`, `find`, `filter` 등을 사용할 때 유용하다.

### useEffect

#### useEffect란?

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘
  - 부수 효과 : 함수 내부에서 함수 외부의 상태를 변경하는 것
- useEffect는 첫 번째 인자로 부수 효과 함수를 받는다.
- useEffect는 두 번째 인자로 의존성 배열을 받는다.
  - 의존성 배열 : 배열 내부의 값이 변경될 때만 부수 효과를 실행한다.
  - 빈 배열을 넣으면 컴포넌트가 처음 렌더링될 때만 부수 효과를 실행한다.
- 렌더링 할때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수효과를 실행한다.

#### 클린업 함수의 목적

```jsx
import React, { useEffect, useState } from "react";
export default function App() {
  const [counter, setCounter] = useState(0);
  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  useEffect(() => {
    function addMouseEvent() {
      console.log("useEffect Counter", counter);
    }

    window.addEventListener("click", addMouseEvent);

    return () => {
      console.log("클린업", counter);
      window.removeEventListener("click", addMouseEvent);
    };
  }, [counter]);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 클린업 함수는 비록 새로운 값을 기반으로 렌더링 뒤에 실행되지만 _변경된 값을 읽는 것이 아니라_ **함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행**한다.
- **이벤트 리스너를 추가할 때** : 이벤트 리스너를 추가하고 제거할 때 사용하여 메모리 누수를 방지한다.

#### 의존성 배열

- 의존성 배열이 없는 useEffect를 사용하는 이유?
  - 클라이언트 사이드에서 실행되는 것을 보장한다.
  - 일반 함수를 사용하면 서버사이드에서도 실행되기 때문에 함수 컴포넌트의 반환을 지연시킨다.

#### useEffect를 사용할 때 주의점

- **의존성 배열에 값을 넣지 않으면 무한 루프**에 빠질 수 있다.(가급적 사용하지 않는다.)
- useEffect의 첫번째 인수에 함수명을 부여한다.
  - useEffect의 목적을 명확히 하고 그 책임을 최소한으로 좁힌다.
- 거대한 useEffect를 만들지 말고 불필요한 외부 함수를 만들지 않는다.
- **비동기 함수를 사용할 때** : useEffect 내부에서 비동기 함수를 사용할 때는 **async 함수를 사용하지 않고** 함수 내부에서 async 함수를 호출한다.
  - 비동기 useEffect는 state의 경쟁 상태를 야기할 수 있고 클린업 함수의 실행 순서도 보장할 수 없기 때문에 useEffect의 인수로 받지 않는다.

### useMemo

- useMemo는 함수의 결과를 저장해 두었다가 같은 인자가 들어오면 이전에 계산한 값을 반환하는 기법으로 리액트에서 발생하는 렌더링을 최소화하기 위해 사용된다.
- 첫번째 인자로 어떤 값을 반환하는 생성 함수를 받고, 두번째 인자로 의존성 배열을 받는다.
- 의존성 배열에 있는 값이 변경되지 않으면 이전 값을 반환한다.

### useCallback

- useCallback은 useMemo와 비슷하지만, **함수를 저장**해 두었다가 **의존성 배열의 값이 변경되지 않으면 이전 함수를 반환**한다.
- 첫번째 인자로 함수를 받고, 두번째 인자로 의존성 배열을 받는다.
- 함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 사용한다.

### useRef
