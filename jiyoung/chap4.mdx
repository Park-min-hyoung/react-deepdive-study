---
title: 04장 정리
date: "2024/04/24"
description: 서버 사이드 렌더링
---

## 서버 사이드 렌더링

### 서버 사이드 렌더링이란?

- 서버에서 렌더링을 처리하는 방식
- 사용자에게 보여줄 페이지를 서버에서 모두 구성한 뒤 사용자에게 제공
- 사용자가 페이지를 요청할 때마다 서버에서 사용자에게 보여줄 페이지를 만들어서 제공

### 서버 사이드 렌더링 장점

#### 최초 페이지 진입이 비교적 빠르다.

- SPA 의 경우 JS 다운로드 후, HTTP 통신 작업이 완료 된 이후 페이지를 그리게 되므로 느리다
- SSR 의 경우 HTTP 통신을 백엔드에서 하는 것이 더 빠르기도 하며, HTML 을 그리는 작업도 서버에서 직접 미리 그려서 내려주기 때문에 속도에서 이점을 가진다

#### 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다

- 검색 엔진은 HTML 의 정적인 데이터를 분석하므로 SPA 의 JS 의 데이터는 읽을 수 없어, SEO 및 메타 데이터 제공에 약점을 가진다

#### 누적 레이아웃 이동이 적다

- 사용자에게 첫페이지를 보여준 이후 뒤늦게 어떤 HTML 정보가 추가 되거나, 삭제되어 화면이 갑자기 변하는 부정적 사용자 경험이 줄어든다.
- 다만, SSR 을 이용한다고 해서 누적 레이아웃 이동으로 부터 완전히 자유로울 순 없다

#### 사용자의 디바이스 성능에 비교적 자유롭다

#### 보안에 좀 더 안전하다

- SSR 의 경우 서버에서 렌더링을 처리하기 때문에, 사용자에게 노출되지 않아 보안에 좀 더 안전하다

### 서버 사이드 렌더링 단점

#### 소스코드를 작성할 때 항상 서버를 고려해야 한다.

- 서버에서 렌더링을 처리하기 때문에, 서버에서 렌더링을 처리할 수 있는 환경이 필요하다
  - 브라우저 전역 객체인 window, sessionStorage, localStorage 등을 사용할 수 없다

#### 적절한 서버가 구축돼 있어야 한다.

- 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 하고, 예기치 않은 장애 상황에 대응할 수 있도록 복구 전략도 필요하다.

---

## More About Next.js ver 13

### App Directory

- Layout: 상태를 유지하고 비용이 많이 드는 재렌더링을 피하면서 경로 간에 UI를 쉽게 공유할 수 있다.
- Server Component: 가장 동적인 응용 프로그램에 대해 서버 우선을 기본값으로 만든다.
  - Server Component를 통해 클라이언트로 전송되는 JavaScript의 양을 줄이면서 복잡한 인터페이스를 구축할 수 있는 기반을 마련하여, 더 빠른 초기 페이지 로드를 가능하게 한다.
- Streaming: 즉시 로딩 상태를 표시하고 렌더링되는 UI 단위로 스트리밍한다.
- Data fetching 지원: async Server Component 및 fetchAPI를 통해 컴포넌트 레벨 fetcing이 가능하다.

#### Server Component의 렌더링

- 렌더링 작업은 개별 경로 세그먼트 및 서스펜스 경계를 ​​기준으로 청크로 분할

  - React는 서버 구성요소를 React Server Component Payload(RSC Payload) 라는 특수 데이터 형식으로 렌더링
  - Next.js는 RSC 페이로드 및 클라이언트 구성 요소 JavaScript 지침을 사용하여 서버에서 HTML을 렌더링

- 클라이언트에서 다음을 수행함
  - HTML은 경로의 빠른 non-interactive 미리보기를 즉시 표시하는 데 사용된다. 이는 초기 페이지 로드에만 해당함
  - React Server Component 페이로드는 클라이언트 및 서버 컴포넌트 트리를 조정하고 DOM을 업데이트하는 데 사용한다
  - JavaScript 지침은 hydrate하는 데 사용된다. 클라이언트 컴포넌트를 선택하고 응용 프로그램을 대화형으로 만든다

#### Next.js에서는 서버 렌더링 전략을 세 가지로 나눈다: 정적렌더링, 동적렌더링, 스트리밍

1. **정적 렌더링(기본값)**

- 빌드 시간 또는 데이터 재검증 후 백그라운드에서 라우트를 렌더링
- 결과는 캐시되고 CDN에 푸시될 수 있다.
- 사용자나 서버 요청 간에 렌더링 작업 결과를 공유할 수 있다.
- 사용자에게 개인화되지 않은 정적 블로그 글이나 제품 페이지 등에 유용하다.

2. **동적 렌더링**

- 각 사용자 요청 시 라우트를 렌더링
- 쿠키나 URL 검색 매개변수 등 요청 시간에만 알 수 있는 사용자 개인화 데이터나 정보가 있는 라우트에 유용하다.

3. **캐시된 데이터를 사용하는 동적 라우트**

- 대부분 웹사이트의 라우트는 완전히 정적이거나 동적이지 않다.
- Next.js에서는 캐시된 데이터와 캐시되지 않은 데이터를 별도로 캐싱하므로 동적 렌더링을 사용하면서도 성능 영향을 줄일 수 있다.

4. **스트리밍**

- 스트리밍은 서버에서 UI를 점진적으로 렌더링할 수 있게 해준다.

  - 작업이 여러 덩어리로 나뉘어 각 덩어리가 준비되는 대로 클라이언트로 스트리밍
  - 전체 콘텐츠 렌더링이 완료되기 전에도 페이지의 일부를 먼저 볼 수 있게 된다.

- Next.js App Router에는 기본적으로 스트리밍 기능이 내장되어 있다.
  - 초기 페이지 로딩 성능을 개선할 뿐 아니라 느린 데이터 fetching으로 인해 전체 라우트 렌더링이 지연되는 UI에서도 도움이 된다. - ex. 제품 페이지의 리뷰

### Data Fetching

- 예시 코드를 보면, async/await 문법을 사용하여 getData 함수 내에서 fetch API를 활용해 데이터를 가져온다. 이렇게 반환된 값은 직렬화되지 않고 Date, Map, Set 등 다양한 타입을 그대로 사용할 수 있다.
- Page 컴포넌트 역시 async 함수로 선언되어 있어 await getData()를 통해 가져온 데이터를 렌더링에 활용할 수 있다.
- 기본 fetch Web API가 확장되어 컴포넌트 수준에서 fetch 요청을 자동으로 중복 제거하고, 데이터를 fetch, 캐시, 재검증할 수 있는 유연한 방법을 제공한다.
- app 디렉토리에서는 레이아웃, 페이지, 컴포넌트 내에서 모두 데이터를 fetch할 수 있고 서버에서 스트리밍된 응답도 지원한다.

### `next/image`, `@next/font`, `next/link`

#### next/image

- `Image` 컴포넌트가 도입되어 레이아웃 변화 없이 이미지를 쉽게 표시하고 필요에 따라 파일을 최적화할 수 있다.
- 기존 Image 컴포넌트보다 클라이언트 측 자바스크립트 양이 줄어들었다.
- 스타일링과 구성이 더 쉬워졌고, 접근성을 위해 기본적으로 alt 태그가 필수이다.
- 웹 플랫폼과 잘 맞춰졌고, 네이티브 지연 로딩으로 인해 hydration이 필요 없어 더 빨라졌다.

  ```jsx
  import Image from "next/image";
  import avatar from "./lee.png";

  export default function Home() {
    // "alt" is now required for improved accessibility
    // optional: image files can be colocated inside the app/ directory
    return <Image alt="leeerob" src={avatar} placeholder="blur" />;
  }
  ```

#### @next/font

- 폰트를 자동 최적화하고 외부 네트워크 요청을 제거하여 프라이버시와 성능이 향상되었다.
- 모든 폰트 파일에 대해 자동 셀프 호스팅이 내장되어 있다.
- CSS `size-adjust` 속성을 사용하여 레이아웃 변화를 자동으로 제거한다.
- 구글 웹폰트를 성능과 프라이버시를 고려하여 편리하게 사용할 수 있다.

  ```jsx
  import { Inter } from "@next/font/google";
  const inter = Inter();
  <html className={inter.className}></html>;
  ```

- 사용자 정의 폰트도 지원되며, 자동 셀프 호스팅, 캐싱, 프리로딩이 가능하다.

  ```jsx
  import localFont from "@next/font/local";
  const myFont = localFont({ src: "./my-font.woff2" });
  <html className={myFont.className}></html>;
  ```

#### next/link

- `next/link`에서 더 이상 `<a>` 자식 요소를 수동으로 추가할 필요가 없다.
- `<Link>`는 항상 `<a>`를 렌더링하고 기본 태그에 props를 전달할 수 있다.

  ```jsx
  import Link from 'next/link'
  // Next.js 12: `<a>` has to be nested otherwise it's excluded
  <Link href="/about">
    <a>About</a>
  </Link>
  // Next.js 13: `<Link>` always renders `<a>`
  <Link href="/about">
    About
  </Link>
  ```
